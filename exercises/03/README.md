Упражнение 3
============

Слайдове
--------

* [PDF](slides/slides.pdf)
* [Код от слайдовете](slides/snippets.scm)

Задачи
------

1. Да се дефинира процедура `(fibonacci n)`, която намира `n`-тото число на
Фибоначи. Реализирайте я чрез рекурсивен процес. Реализирайте я чрез итеративен
процес.

2. Дефинираме функция `f` по следните правила:

   f(n) = n, ако n < 3

   f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3), ако n ≥ 3

   Напишете процедура, пресмятаща `f`. Реализирайте я чрез рекурсивен процес.
Реализирайте я чрез итеративен процес.

3. Триъгълникът на Паскал представлява следната фигура от числа:

   ```
       1
      1 1
     1 2 1
    1 3 3 1
   1 4 6 4 1
      ...
   ```

   Числата, намиращи се по страните на триъгълника, са единици. Всяко число,
намиращо се вътре в триъгълника, е сумата на двете числа непосредствено над
него. Напишете процедура `(binomial-coefficient row index)`, пресмятаща елемента
от триъгълника на Паскал, намиращ се на ред `row` и позиция в реда `index`.
Броенето на редовете и позициите започва от 1.

4. В дефинициите на `sum`, `product` и `accumulate` от слайдовете при всяко
рекурсивно извикване на съответната процедура към аргумента `a` се прибавя 1.
Напишете по-общ вариант на процедурите `sum`, `product` и `accumulate`, като
добавите нов параметър към съответната процедура, който да пресмята следващата
стойност на `a`. Пример:

   ```scheme
   (define (identity x) x)
   (define (2+ x) (+ x 2))

   (sum identity 1 2+ 5) ; 9
   (product identity 1 2+ 5) ; 15
   (accumulate + 0 identity 1 2+ 5) ; 9
   (accumulate * 1 identity 1 2+ 5) ; 15
   ```

   Дефинирайте `accumulate` чрез итерация.

5. Напишете процедура `(count predicate a b)`, която връща броя на целите числа
в интервала [`a`, `b`], за които предикатът `predicate` е истина. `a` и `b` са
цели числа. Имплементирайте я чрез `sum`. Имплементирайте я чрез `accumulate`.

6. Напишете процедура, която връща броя на палиндромите в даден интервал.

7. Напишете процедура `(exists? predicate a b)`, която проверява дали съществува
цяло число в интервала [`a`, `b`], за което предикатът `predicate` е истина. `a`
и `b` са цели числа.

8. Напишете процедура `(for-all? predicate a b)`, която проверява дали за всяко
цяло число в интервала [`a`, `b`] предикатът `predicate` е истина. `a` и `b` са
цели числа.

9. Напишете процедура `(double f)`, която връща композицията `f` ∘ `f`, където
`f` е едноаргументна процедура. Пример:

   ```scheme
   (define (1+ x) (+ x 1))
   (define 2+ (double 1+))

   (2+ 40) ; 42
   ```

10. Нека `f` и `g` са едноаргументни функции. Композицията `f` ∘ `g` е функцията
x ↦ f(g(x)). Напишете процедура `(compose f g)`, която връща композицията `f` ∘
`g`. Пример:

    ```scheme
    (define (1+ x) (+ x 1))
    (define (square x) (* x x))

    ((compose square 1+) 6) ; 49
    ```

11. Нека `f` е функция на един аргумент и `n` е цяло неотрицателно число.
Дефинираме `n`-тото прилагане на функцията `f` да бъде функция, дефинирана по
следния начин:

    f<sup>0</sup>(x) = x

    f<sup>n</sup>(x) = f(f<sup>n-1</sup>(x))

    Напишете процедура `(repeated f n)`, която връща `n`-тото прилагане на `f`.
Пример:

    ```scheme
    (define (square x) (* x x))

    ((repeated square 2) 5) ; 625
    ```
