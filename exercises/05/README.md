Упражнение 5
============

Разгледано на упражнението
--------------------------

* Процедури `(every? p l)` и `(any? p l)`, проверяващи съответно дали за всеки
елемент на списъка `l` е изпълнен предикатът `p` и дали съществува елемент от
списъка `l`, за който е изпълнен предикатът `p`. Използваме ги в задачи
[2](endomorphism.scm) и [3](meet-twice.scm).

* Процедура `(enumerate-interval from to)`, която връща списък от целите числа в
интервала [`from`, `to`], подредени в нарастващ ред от `from` до `to`, където
`from` и `to` са цели числа. Използваме я в задачa [3](meet-twice.scm).

* Процедури `(take-while p l)` и `(drop-while p l)`:

  * `take-while` връща списък от последователните елементи от началото на
  списъка `l`, за които предикатът `p` е изпълнен. Примери:
  ```scheme
  (take-while even? '(2 4 6 1 8 10 11)) ; -> (2 4 6)
  (take-while even? '(1 2 4 6 1 8 10 11)) ; -> ()
  ```

  * `drop-while` връща списък с елементите от списъка `l` без последователните
  елементи от началото на `l`, за които предикатът `p` е изпълнен. Примери:
  ```scheme
  (drop-while even? '(2 4 6 1 8 10 11)) ; -> (1 8 10 11)
  (drop-while even? '(1 2 4 6 1 8 10 11)) ; -> (1 2 4 6 1 8 10 11)
  ```

  * Използваме ги в задача [4](next-look-and-say.scm).

* Процедура [`(selection-sort l)`](selection-sort.scm), която сортира списъка
`l` по метода на пряката селекция.

* Процедура [`(quicksort l)`](quicksort.scm), която сортира списъка `l` чрез
алгоритъма "бързо сортиране" (quicksort).

* Процедура [`(prime-sum-pairs n)`](prime-sum-pairs.scm), която по дадено цяло
положително число `n` намира всички наредени тройки (i, j, i + j), за които:

  i и j са цели положителни числа,\
  1 ≤ j < i ≤ n и\
  i + j е просто.

Примерни задачи за първо контролно
----------------------------------

1. Да се напише процедура `(middle-digit n)`, която намира средната цифра от
записа на подадено естествено число `n`. Ако `n` е с четен брой цифри,
процедурата да връща `-1`. Примери:

   ```scheme
   (middle-digit 452) ; -> 5
   (middle-digit 4712) ; -> -1
   ```

2. Нека е даден списък `l` от числа и двуместна операция над числа ⊕. Функцията
`f` наричаме ендоморфизъм над `l` спрямо операцията ⊕, ако `f` трансформира `l`
в себе си, запазвайки операцията ⊕, тоест

   ∀x∈l f(x)∈l и\
   ∀x,y∈l f(x) ⊕ f(y) = f(x ⊕ y).

   Да се реализира процедура `(endomorphism? l op f)`, която проверява дали `f`
   е ендоморфизъм над `l` спрямо операцията `op`. Примери:
   ```scheme
   (endomorphism? '(0 1 4 6) + (lambda (x) (remainder x 3))) ; -> #t
   (endomorphism? '(0 1 4 5 6) + (lambda (x) (remainder x 3))) ; -> #f
   ```

3. Да се напише процедура `(meet-twice? f g a b)`, която проверява дали в
целочисления интервал [`a`, `b`] съществуват две различни цели числа `x` и `y`
такива, че f(x) = g(x) и f(y) = g(y). Примери:

   ```scheme
   (meet-twice? (lambda (x) x) (lambda (x) (- x)) -3 1) ; -> #f
   (meet-twice? (lambda (x) x) sqrt 0 5) ; -> #t
   ```

4. Казваме, че списъкът `x` = (x<sub>1</sub> x<sub>2</sub> … x<sub>2n</sub>) от
цели числа се получава от прочитането (look-and-say) на списъка `y`, ако `y` се
състои от последователно срещане на x<sub>1</sub> пъти x<sub>2</sub>, последвано
от x<sub>3</sub> пъти x<sub>4</sub> и така нататък до x<sub>2n-1</sub> пъти
x<sub>2n</sub>. Да се дефинира процедура `(next-look-and-say y)`, която по даден
списък `y` намира списъка `x`, получен от прочитането на `y`. Примери:

   ```scheme
   (next-look-and-say '(1 1 2 3 3)) ; -> (2 1 1 2 2 3)
   (next-look-and-say '(1 1 2 2 3 3 3 3)) ; -> (2 1 2 2 4 3)
   ```
