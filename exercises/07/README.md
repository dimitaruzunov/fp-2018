Упражнение 7
============

Асоциативни списъци
-------------------

* конструктор
  * `(make-alist fn keys)`

* селектори
  * `(keys alist)`
  * `(values alist)`
  * `(assoc key alist)`, `(assv key alist)`, `(assq key alist)`

* трансформации
  * `(del-assoc key alist)`
  * `(add-assoc key value alist)`

Графи
-----

1. Ще представяме граф, чрез списък на съседство. Дефинирайте следните основни
процедури за работа с графи:

* конструктори
  * `(empty-graph)` - връща празен граф (с празни множества от върхове и ребра).
  * `(make-graph vs)` - връща граф с върхове `vs` (и празно множество от ребра).

* селектори
  * `(vertices g)` - връща списък от върховете в графа `g`.
  * `(children v g)` - връща списък от децата на върха `v` в графа `g`.
  * `(edge? u v g)` - проверка за ребро от върха `u` до върха `v` в графа `g`.
  * `(map-children v fn g)` - връща списък от прилаганията на процедурата `fn`
  върху всяко дете на върха `v` в графа `g`.
  * `(search-child v p g)` - връща първото дете на върха `v` в графа `g`, което
  удовлетворява предиката `p`, ако има такова, иначе връща `#f`.

* трансформации
  * `(add-vertex v g)` - добавяне на връх `v` в графа `g`.
  * `(remove-vertex v g)` - премахване на връх `v` от графа `g`.
  * `(add-edge u v g)` - добавяне на ребро (`u`, `v`) в графа `g`.
  * `(remove-edge u v g)` - премахване на ребро (`u`, `v`) от графа `g`.

2. Дефинирайте процедура `(degree v g)`, която връща степента на върха `v` в
ориентирания граф `g`.

3. Дефинирайте процедура `(edges g)`, която връща списък с всички ребра на
ориентирания граф `g`.

4. Дефинирайте процедура `(symmetric? g)`, която проверява дали ориентираният
граф `g` е симетричен.

5. Дефинирайте процедура `(invert g)`, която инвертира ориентирания граф `g`,
тоест връща нов граф, който има ребра от вида (v, u) за всяко ребро (u, v) от
`g`.

6. Дефинирайте процедура `(path? u v g)`, която проверява дали има път между
върховете `u` и `v` в графа `g`.

7. Дефинирайте процедура `(acyclic? g)`, която проверява дали графът `g` е
ацикличен.

Потоци
------

1. Дефинирайте процедура `(repeat value)`, която връща безкраен поток, който
генерира стойности `value`.

   ```scheme
   (repeat 1) ; 1, 1, ..., 1, 1, ...
   (repeat '(1 2 3)) ; (1 2 3), (1 2 3), ..., (1 2 3), (1 2 3), ...
   ```

2. Дефинирайте процедура `(cycle l)`, която връща безкраен поток, който генерира
елементите на списъка `l`.

   ```scheme
   (cycle (1)) ; 1, 1, ..., 1, 1, ...
   (cycle (1 2 3)) ; 1, 2, 3, 1, 2, 3, 1, ...
   ```

3. Дефинирайте процедура `(iterate f x)`, която връща безкрайния поток
`x, f(x), f(f(x)), f(f(f(x))), ...`.
